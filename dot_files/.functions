# @file .functions
# â˜…  Carrybag functions
# @author Alister Lewis-Bowen <alister@different.com>
# @see .bashrc

#
# List usage metadata from carrybag dot files of the format:
# @usage carrybag ... list commands provided by carrybag
#

carrybag () {
    #            0        1         2         3         4
    #            1234567890123456789012345678901234567890
    local _line='..........................'
    local _base=$(dirname $(ls -l ~/.functions | awk '{print $11}'))
    local _usage _cmd _sum
    IFS=$'\n'
    for _usage in $(find $_base | grep -v 'vim/backup' | xargs grep -s '# @usage' | grep -v 'xargs grep'); do
        _usage=${_usage#*@usage }
        _cmd=${_usage%% ...*}
        _sum=${_usage#*... }
        printf "$(color bd)%s$(color) %s %s\n" $_cmd ${_line:${#_cmd}} $_sum
    done
    unset IFS
}

#
# @usage compress file/dir ... tar-gzip a file or directory
#

compress () {
    local source="$1"
    local file files archive
    _setHelp 'compress file/dir' 'tar-gzip a file or directory'

    if [ -s "$source" ]; then
        archive=$(basename "$source")
        files="$source"

        # for multiple files...
        if [ ! -d "$source" ]; then
            if [ $(ls "$source"|wc -l) -gt '2' ]; then
                archive=$(basename $(dirname "$source"))
                files=''
                for file in $(ls "$source"); do
                    files=$files' '$file
                done
                source=$files
            fi
        fi

        tar -czvf ${archive}.tar.gz $files
    fi
}

#
# @usage uncompress file/dir ... un-archive a tar.gz file
#

uncompress () { [ -s "$1" ] && tar -xzvf "$1" ; }

#
# @usage todir string ... mkdir and cd into it
#

todir () { mkdir -p $1 && cd $1 ; }

#
# @usage ffile string ... find a file from this directory down
#

ffile () { find . | grep -i --color=always "$1" 2>/dev/null ;  }

#
# @usage ftext string ... find text in files from this directory down
#

ftext () { find . | xargs grep -i -C 2 --color=always "$1" 2>/dev/null; }

#
# @usage fproc string ... find a process matching the given string
#

fproc () { ps aux | grep "$1" | grep -v 'grep' ; }

#
# @usage kproc string ... kill a set of processes matching the given string
#

kproc () { fproc "$@" | awk '{print $2}' | xargs kill -9 ; }

#
# @usage sshkey ... display public rsa key or create ssh keys if none found
#

sshkey () {
    if [ -e ~/.ssh/id_rsa.pub ]; then
        cat ~/.ssh/id_rsa.pub
    else
        local answer
        echo -n "You don't have a public key. Want to create one? (Y/N): ";
        read answer
        case "$answer" in
            y|Y)
                type ssh-keygen >/dev/null 2>&1 ||
                    { echo >&2 "ssh-keygen is not installed."; exit 1; }
                ssh-keygen -t rsa -C "${USER}@${HOSTNAME}"
                ;;
        esac
    fi
}

#
# @usage ips [interface] ... list ips available on this machines NICs
#

ips () { ifconfig $1 | grep 'inet ' | awk '{print $2}' | grep -v 127.0.0.1 ; }

#
# @usage end file ... show the last 100 lines of a given file
#

end () { tail -n100 $1; }

#
# @usage bman command ... show bash help or a built-in command
#

bman () { man bash | less -p "^       $1 "; }

#
# @usage rcsedit file ... rcs wrapped edit
#

rcsedit () {
    if [ "$(command -v rcs)" == "" ]; then
        [ ! -e $(dirname $1)/RCS ] && mkdir $(dirname $1)/RCS   # Create RCS dir next to file
        co -l $1; $EDITOR $1; ci $1; co $1                      # rcs wrapped edit
    else
        $EDITOR $1;                                             # Regular edit if rcs not installed
    fi
}

#
# @usage cleanup file ... clean out tabs, trailing spaces, carriage returns, etc.
#
# DOS, Windows   0D 0A   (\r\n)
# UNIX           0A      (\n)
# Machintosh     0D      (\r)
#

cleanup () {
    cp $1 $1.bak
    local tmp=$(mktemp -t ${RANDOM})
    cat $1 | \
        perl -pe 'if (defined $x && /\S/) { print $x; $x = ""; } $x .= "\n" x chomp; s/\s*?$//; if (eof) { print "\n"; $x = ""; }' | \
        perl -pe 's/\t/    /g' | \
        perl -pe 's/\r\n$/\n/g' | \
        perl -pe 's/\r$/\n/g' \
        > $tmp
    mv $tmp $1
}

#
# @usage watch [seconds] command ... execute a program periodically, showing output fullscreen
# NOTE: If an alias is messing with your command then apply a backslash before it
#

watch () {
    local delay=0
    if [ $# -gt 1 ]; then delay=$1; shift; fi
    while :; do clear; eval "$@"; sleep $delay; done
}

#
# Additional function customizations/overrides
#

[ -f ~/.functions_local ] && . ~/.functions_local
